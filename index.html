<html lang="hr">
  <head>
    <meta charset="utf-8" />
    <title>Ortogonalni polinomi</title>
    <script src="https://sagecell.sagemath.org/static/jquery.min.js"></script>
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <script>$(function () {
    sagecell.makeSagecell({
      inputLocation: 'div.compute', 
      hide: ["editorToggle", "permalinks"], //
      evalButtonText: 'Izračunaj'
    });
    });
    </script>
    <link rel="stylesheet" type="text/css" href="https://sagecell.sagemath.org/static/sagecell_embed.css">
  <BODY BGCOLOR="#6699CC">

  <style>
	body {
    	background:
        linear-gradient(-90deg, rgba(0,0,0,.05) 1px, transparent 1px),
        linear-gradient(rgba(0,0,0,.05) 1px, transparent 1px), 
        linear-gradient(-90deg, rgba(0, 0, 0, .04) 1px, transparent 1px),
        linear-gradient(rgba(0,0,0,.04) 1px, transparent 1px),
        linear-gradient(transparent 3px, #f2f2f2 3px, #f2f2f2 78px, transparent 78px),
        linear-gradient(-90deg, #aaa 1px, transparent 1px),
        linear-gradient(-90deg, transparent 3px, #f2f2f2 3px, #f2f2f2 78px, transparent 78px),
        linear-gradient(#aaa 1px, transparent 1px),
        #f2f2f2;
    	background-size:
        4px 4px,
        4px 4px,
        80px 80px,
        80px 80px,
        80px 80px,
        80px 80px,
        80px 80px,
        80px 80px;
	}
  </style>	
  	
  </head>
  
<body>

<h1><center> Metoda Regula Falsi</center></h1>
<h2>1 Metoda polovljenja (bisekcije)</h2>
<p>Najjednostavnija metoda nalaženja nultočaka nelinearne funkcije je metoda polovljenja.
Ona funkcionira za sve neprekidne funkcije, no zato ima i najlošiju ocjenu pogreške.
Osnovna pretpostavka za primjenu algoritma polovljenja je neprekidnost funkcije $f$ na
intervalu $[a,b]$ uz dodatni uvjet
<center>$f(a) \cdot f(b) < 0$ </center>
</br>
Ovaj uvjet nam osigurava da funkcija $f$ ima na intervalu $[a,b]$ barem jednu nultočku.
Naravno, ako je $f(a) \cdot f(b) < 0$ to ne znači da f nema nultočaka na $[a,b]$  : može ih imati paran broj ili nultočku parnog
reda. U prvom slučaju možemo riješiti problem boljom separacijom intervala $[a,b]$  ; no
u drugom slučaju metoda polovljenja neće dati rješenje.</p>
</br>

<p> Uzmimo funkciju $f(x)=x^3+1$ te pogledajmo njezin grafički prikaz. Vidimo da za odabrani interval, primjerice $[-2,2]$ postoji realna nultočka </p>
<div class="compute"><script type="text/x-sage">
p1=plot (x^3+1)
p2= point((-1,0))
show(p1+p2)
</script>
</div>


<p>Uvjerimo se da uvjet $f(a) \cdot f(b) < 0$ ne mora uvijek značiti da funkcija nema nultočaka u zadanom intervalu</p>
<div class="compute"><script type="text/x-sage">
@interact
def g(f=x^2,a=-3,b=3):
    show(plot(f,(x,a,b)))
    if (f(a)*f(b)<0):
	    print 'Postoji nultočka u tom intervalu'
    else:
        print 'Ne postoji nultočka u tom intervalu'
</script>
</div>



<h2>2 Regula Falsi</h2>
<p>Metoda regula falsi ili metoda krivih položaja služi za rješavanje jednadžbe 
$f(x) = 0$, gdje je $f \in C^2[a, b]$ funkcija zadana na intervalu $[a, b]$. 
Pogledajmo osnovne karakteristike i svojstva ove metode.</p>
</br>
<p> Neka je $f$ neprekidna funkcija definirana na zatvorenom intervalu $[a, b]$. Tada svaki kompleksni broj $\xi$,
koji je rješenje jednadžbe <center>$f(x) = 0$,</center> nazivamo nultočkom funkcije $f$. Mi ćemo se ograničiti na istraživanje samo 
realnih nultočaka funkcije $f$ (sjecišta grafa funkcije s osi $x$). Općenito se može dogoditi da neka funkcija ima 
više realnih nultočaka, od kojih neke mogu biti višestruke, ili da uopće nema realnih nultočaka.
Ako je funkcija $f$ neprekidna na intervalu $I = [a, b]$ i ako na rubovima intervala prima suprotne
vrijednosti (tj. ako je $f(a) \cdot f(b) < 0)$, onda postoji barem jedna točka $\xi$ za koju vrijedi $f(\xi) = 0$.</p>

<h3>Primjer a)</h3> 
Dana funkcija nema realnih nultočaka na cijeloj domeni za proizvoljan $c \in [1,20]$:
<div class="compute"><script type="text/x-sage">
var('x')
@interact
def g(c=(1,20)):
    f = x^2+c
    p = plot(f,-5,5, thickness=2)
    print solve(x^2+c,x)
    show (p)
 </script>
</div>

<h3>Primjer b)</h3> 
Dana funkcija ima jednu realnu nultočku na cijeloj domeni za proizvoljan $c \in [-20,0]$:
<div class="compute"><script type="text/x-sage">
var('x')
@interact
def g(c=(-20,0)):
    f = x^3+c
    p = plot(f,-5,5, thickness=2)
    print solve(x^3+c,x)
    show (p)
 </script>
</div>

<h3>Primjer c)</h3> 
Dana funkcija ima dvije realne nultočke na segmentu $[-2, 2]$:
<div class="compute"><script type="text/x-sage">
var('x')
@interact
def g(a=(10,20),c=(-1,-20)):
    f = a*x^2+c
    p = plot(f,-5,5, thickness=2)
    print solve(a*x^2+c,x)
    show (p)
 </script>
</div>

<p>Ako je prva derivacija $f'$ stalnog predznaka na intervalu $I$, onda
je to i jedina nultočka funkcije $f$ na intervalu $I$. Na taj se način posao oko traženja realnog rješenja
jednadžbe svodi na dva koraka:
1. Separirati interval $I$ u kome funkcija ima nultočku,
2. Nekom iterativnom metodom odrediti aproksimaciju nultočke $\xi$ s unaprijed zadanom točnošću.
Spomenuti interval $I = [a, b]$, u kome se nalazi barem jedna nultočka funkcije $f$, treba odrediti tako
da na njegovim rubovima funkcija prima vrijednosti suprotnog predznaka, tj. da bude <center>$f(a) \cdot f(b) < 0$.</center> </p>

<h2> Regula Falsi </h2>
<p> <i>Regula falsi (metoda krivih položaja)</i> je metoda, koju možemo smatrati jednom modifikacijom Newtonove
metode, odnosno jednom varijantom metode sekanti. Pretpostavimo da je funkcija $f$ neprekidna na
zatvorenom intervalu $I = [a, b]$ i da je $f(a)\cdot f(b) < 0$. Označimo $x_0\colon = a, b_0\colon = b$ i povucimo pravac
točkama $(x_0, f(x_0)), (b_0, f(b_0))$. On siječe os $x$ u točki 
<center>$c_1=\frac{x_0f(b_0)-b_0f(x_0)}{f(b_0)-f(x_0)}$, $x_0 < c_1 < b_0$. </center> </p>



<p>Naime, jednadžba pravca kroz dvije točke $(x_0, f(x_0)), (b_0, f(b_0))$ jest 
<center>$y-f(x_0)=\frac{f(b_0)-f(x_0)}{b_0-x_0}(x-x_0)$</center> </p>
<p>Ako pravac siječe os $x$ u točki $c_1$, tada će $y$ koordinata te točke nužno biti nula pa vrijedi
<center>$f(x_0)+\frac{f(b_0)-f(x_0)}{b_0-x_0}(c_1-x_0)=0$</center> </p>

<p>Ako je $f(c_1)=0$, nultočka je pronađena. U protivnom postupimo na sljedeći način:<p>
<center>ako je $f(c_1)f(x_o)>0$, $x_1=c_1$, $b_1=b_0$; inače $x_1=c_1$, $b_1=x_0$.</center> </p>
Ponavljajući postupak dobivamo niz $(x_n)$ koji linearnom brzinom konvergira prema jednom korijenu
jednadžbe $f(x) = 0$ na intervalu $[a, b]$. Prema tome, ovu metodu možemo smatrati i jednom varijantom
metode bisekcije.

Ako je $x_n$ jedna aproksimacija nultočke $\xi$ u intervalu $I = [a, b]$ i ako je $f$ derivabilna funkcija, takva
da je $\lvert f'(x)\rvert > 0, x \in I$, onda vrijedi ovakva ocjena apsolutne pogreške
<center>$\lvert \xi - x_n \rvert \le \frac{\lvert f(x_n)\rvert}{m_1}$, gdje je 
$ 0 < m_1 = min_{\substack{ x \in I}}\lvert f'(x) \rvert$.</center>

Budući da je rješenje $\xi$ jednadžbe $f(x) = 0$ obično granična vrijednost jednog beskonačnog niza,
postavlja se pitanje kada zaustaviti iterativni proces. Ako želimo da apsolutna pogreška aproksimacije
$x_n$ nultočke $\xi$ ne bude veća od $\epsilon > 0$, onda je dovoljno ispuniti uvjet $\frac{f(x_n)}{m_1}<\epsilon$.</p>
 
<h2> Numerički eksperimenti</h2>
 <p>Na nekoliko numeričkih primjera ilustrirat ćemo prednosti i nedostatke metode regula falsi.</p>
 
<h3> Primjer a)</h3>
 <p>S točnošću $\xi = 0.00005$ treba odrediti realnu nultočku funkcije $f(x) = x^3 + 4x^2 − 10$ 
 Ova funkcija ima tri nultočke, od kojih su dvije imaginarne i jedna realna. Realnu, koju možemo
lokalizirati u intervalu $I = [−4, 2]$, ćemo i potražiti.</p>
 
<div class="compute"><script type="text/x-sage">
var('x')
f = (x^3+4*x^2-10)
p = plot(f,-4,3, thickness=2)
show (p)
 </script>
</div>

 
 <div class="compute"><script type="text/x-sage">
x = var('x')
f(x) = x^3 + 4*x^2 - 10
# lijevi rub intervala
a = -4
# desni rub interavala
b = 2
# maksimalni broj iteracija
max_it = 100
# zeljeni broj decimala
N = 5
# tolerancija
tol = 10^(-N)

# Trazi minimum funkcije f na intervalu [a,b] sa tocnoscu tol.
def minimum_fun(f, a, b, eps):
    t = a;
    min = f(x=a);
    while t < b:
        if f(x=t) < min:
            min = f(x=t)
        t = t + eps;
    return min

# Racuna podijeljenu razliku.
def pod_raz(f, a, b):
    return (f(x=b)-f(x=a))/(b-a)

def regula_falsi_der(f, a, b, max_it, tol):    
    if f(x=a)*f(x=b) >= 0:
        print 'Funkcija nije pogodna za metodu regule falsi.'
        return      
    it = 0
    while it < max_it:
        x0 = b - f(x=b) / pod_raz(f,a,b)
        if f(x=a)*f(x=x0)>=0:
            a = x0
        else:
            b = x0
        #mv = minimum_fun(f.diff().abs(), a, b, 0.1)
        mv, mx = find_local_minimum(f.diff().abs(), a, b)
        if abs(f(x=x0)) / mv < tol:
            p=ceil(f)
            print 'Korijen je %.5f' % x0
            print 'Najveće cijelo korijena',floor(x0)
            print 'Najmanje cijelo korijena',floor(x0)+1
            print 'Vrijednost funkcije u x0 iznosi približno',p(x=x0)
            return
        it = it + 1

regula_falsi_der(f, a, b, max_it, tol)
 </script>
</div>
 
 <p>Navedeni interval najprije smanjimo izvršavajući dvije iteracije metode bisekcije. Nakon deset iteracija
metodom regula falsi vidimo da se tražena nultočka nalazi u intervalu $<1,2>$, a iznosi $x = 1.36522$.</p>
Odredimo tijek iterativnog procesa te ga prikažimo tablicom ($a_0$ je lijeva granica, a $b_0$ desna granica intervala).
 
 <div class="compute"><script type="text/x-sage">
x = var('x')
f(x) = x^3 + 4*x^2 - 10
# lijevi rub intervala
a = -4
# desni rub interavala
b = 2
# maksimalni broj iteracija
max_it = 100
# zeljeni broj decimala
N = 5
# tolerancija
tol = 10^(-N)

# Trazi minimum funkcije f na intervalu [a,b] sa tocnoscu tol.
def minimum_fun(f, a, b, eps):
    t = a;
    min = f(x=a);
    while t < b:
        if f(x=t) < min:
            min = f(x=t)
        t = t + eps;
    return min

# Racuna podijeljenu razliku.
def pod_raz(f, a, b):
    return (f(x=b)-f(x=a))/(b-a)

def regula_falsi_der(f, a, b, max_it, tol):
    if f(x=a)*f(x=b) >= 0:
        print 'Funkcija nije pogodna za metodu regule falsi.'
        return
    it = 0
    while it < max_it:
        x0 = b - f(x=b) / pod_raz(f,a,b)
        if f(x=a)*f(x=x0)>=0:
            a = x0
        else:
            b = x0
        print 'n=%6s'%it
        print 'a_0=%6s' %a.n(digits=3)
        print 'b_0=%6s' %b.n(digits=3)
        print 'x_n:%.8f\n '  %x0 
     
        mv, mx = find_local_minimum(f.diff().abs(), a, b)
        if abs(f(x=x0)) / mv < tol:
            print 'Korijen je x_n:%.5f' % x0
            return
        it = it + 1
    
    print 'Dostignut maksimalan broj iteracija. Trenutna aprox. korijena je %.8f' % x0
regula_falsi_der(f, a, b, max_it, tol)
 </script>
</div>


<table border="1" style="width:300px">
<tr>
  <td>n</td>
  <td>$a_0$</td> 
  <td>$b_0$</td>
  <td>$x_n$</td>
</tr>
<tr>
  <td>0</td>
  <td>-1.5</td> 
  <td>2.00</td>
  <td>-1.5</td>
</tr>
<tr>
  <td>1</td>
  <td>-0.667</td> 
  <td>2.00</td>
  <td>-0.666</td>
</tr>
<tr>
  <td>2</td>
  <td>0.343</td> 
  <td>2.00</td>
  <td>0.34210526</td>
</tr>
</tr>
<tr>
  <td>3</td>
  <td>1.01</td> 
  <td>2.00</td>
  <td>1.01197400</td>
</tr>
<tr>
  <td>4</td>
  <td>1.27</td> 
  <td>2.00</td>
  <td>1.26685969</td>
</tr>
<tr>
  <td>5</td>
  <td>1.34</td> 
  <td>2.00</td>
  <td>1.33981234</td>
</tr>
<tr>
  <td>6</td>
  <td>1.36</td> 
  <td>2.00</td>
  <td>1.35879736</td>
</tr>
<tr>
  <td>7</td>
  <td>1.36</td> 
  <td>2.00</td>
  <td>1.36361075</td>
</tr>
<tr>
  <td>8</td>
  <td>1.36</td> 
  <td>2.00</td>
  <td>1.36482295</td>
</tr>
<tr>
  <td>9</td>
  <td>1.37</td> 
  <td>2.00</td>
  <td>1.36512772</td>
</tr>
<tr>
  <td>10</td>
  <td>1.37</td> 
  <td>2.00</td>
  <td>1.36520431</td>
</tr>
<tr>
  <td>11</td>
  <td>1.37</td> 
  <td>2.00</td>
  <td>1.36522355</td>
</tr>
</table>

<p> Promotrimo grafički prikaz funkcije u svakoj iteraciji. Uočavamo da se iz iteracije u iteraciju 
sve više približavamo traženoj vrijednosti nultočke funkcije.</p>

 <div class="compute"><script type="text/x-sage">
x = var('x')
f(x) = x^3 + 4*x^2 - 10
# lijevi rub intervala
a = -4
# desni rub interavala
b = 2
# maksimalni broj iteracija
max_it = 100
# zeljeni broj decimala
N = 5
# tolerancija
tol = 10^(-N)

# Racuna podijeljenu razliku.
def pod_raz(f, a, b):
    return (f(x=b)-f(x=a))/(b-a)

def regula_falsi_der(f, a, b, max_it, tol):
    if f(x=a)*f(x=b) >= 0:
        print 'Funkcija nije pogodna za metodu regule falsi.'
        return
    it = 0
    while it < max_it:
        x0 = b - f(x=b) / pod_raz(f,a,b)
        if f(x=a)*f(x=x0)>=0:
            a = x0
        else:
            b = x0
        
        P1=point((0, 0), size=40)
        L1=line([(a,f(a)),(b,f(b))],color="red",thickness=2 )
        d=plot(x^3 + 4*x^2 - 10,(-3,3),thickness=2.0)
        show(P1+L1+d, figsize=4)
        print 'n=%6s'%it
        print 'a_0=%6s' %a.n(digits=3)
        print 'b_0=%6s' %b.n(digits=3)
        print 'x_n:%.8f\n '  %x0 
     
        mv, mx = find_local_minimum(f.diff().abs(), a, b)
        if abs(f(x=x0)) / mv < tol:
            print 'Korijen je x_n:%.5f' % x0
            return
        it = it + 1
    
    print 'Dostignut maksimalan broj iteracija. Trenutna aprox. korijena je %.8f' % x0
regula_falsi_der(f, a, b, max_it, tol)
 </script>
</div>

<h2>3 "Cobweb plot"- Orbita logističkog preslikavanja</h2>
<p> "Cobweb" (paukov) dijagram je grafički alat koji se koristi u matematici za istraživanje kvalitativnog
ponašanja jednodimenzionalne iterativne funkcije, kao što je logistička funkcija. Korištenjem "cobweb" dijagrama 
moguće je donijeti zaključke o dugoročnom ponašanju funkcije pod početnim uvjetima. </p>

<h3>Metoda</h3>
<p> Za danu iterativnu funkciju $f \colon \mathbb{R} \to \mathbb{R}$ postoji graf koji se sastoji od simetrale prvog i trećeg kvadranta 
(pravca $y=x$) i krivulje dane jednadžbom $y=f(x)$. Da bismo nacrtali ponašanje vrijednosti $x_0$, primjenjujemo sljedeće korake:
<br>
1. Pronađimo točku krivulje koja sadrži $x$ koordinatu jednaku $x_0$. Ta točka ima koordinate $x_0,f(x_0)$
<br>
2. Nacrtajmo pravac paralelan s $x$-osi, koji siječe početnu simetralu. Točka presjeka ima koordinate $f(x_0),f(x_0)$.
<br>
3. Nacrtajmo pravac paralelan s $y$-osi, koji siječe početnu krivulju. Točka presjeka ima koordinate $f(x_0),f(f(x_0))$.
<br>
4. Ponavljajmo korake 2. i 3.

 <div class="compute"><script type="text/x-sage">
 def cobweb(a_function, start, mask = 0, iterations = 20, xmin = 0, xmax = 1):
    basic_plot = plot(a_function, xmin = xmin, xmax = xmax)
    id_plot = plot(lambda x: x, xmin = xmin, xmax = xmax)
    iter_list = []
    current = start
    for i in range(mask):
        current = a_function(current)
    for i in range(iterations):
        iter_list.append([current,a_function(current)])
        current = a_function(current)
        iter_list.append([current,current])
    cobweb = line(iter_list, rgbcolor = (1,0,0))
    return basic_plot + id_plot + cobweb
var('x')
@interact
def cobwebber(f_text = input_box(default = "3.8*x*(1-x)",label = "Funkcija", type=str), start_val = slider(0,1,.01,.5,label = 'Početna vrijednost'), its = slider([2^i for i in range(0,12)],default = 16, label="Iteracija")):
    def f(x):
        return eval(f_text)
    show(cobweb(f, start_val, iterations = its))
  </script>
</div>
</body>

<script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript"></script>
<!-- želim skrolanje, ne želim brojeve stranica -->
<style type="text/css">
.remark-container {
  overflow-y: scroll;
}
.remark-slide-scaler {
  overflow-y: scroll;
      }
.remark-slide-number{
  display:none;
      }      
</style>


<!-- load MathJax -->
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured"></script>

<!-- Initialize (has to go in <script> tag **without** SRC attribute) -->
<script type="text/javascript">

    // Setup MathJax
    MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" },
               extensions: ["AMSmath.js", "AMSsymbols.js"]  
    },
        tex2jax: { 
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ['\[','\]'] ],
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    });
    MathJax.Hub.Queue(function() {
        $(MathJax.Hub.getAllJax()).map(function(index, elem) {
            return(elem.SourceElement());
        }).parent().addClass('has-jax');
    });
    
    MathJax.Hub.Configured();
</script>

</html>
